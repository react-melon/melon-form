{"version":3,"sources":["/src/util/dataPathMap.js"],"names":["make","remove","move","splice","swap","setInWithPath","target","prefix","startIndex","map","isRootArray","Array","isArray","dataPath","value","tokens","firstToken","numbericFirstToken","parseInt","isNaN","slice","Object","keys","reduce","nextMap","key","from","to","replace","pointer","arr","start","deleteCount","replacements","replaceCount","length","i","len","fromKey","toKey","callback","path","toModifyKeyMap","item","index","currentPath","currentDataPath"],"mappings":"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","file":"dataPathMap.js","sourcesContent":["/**\n * @file data path map\n * @author leon <ludafa@outlook.com>\n */\n\nimport {walk, compilePath} from './dataPath';\nimport startsWith from 'lodash/startsWith';\nimport toPath from 'lodash/toPath';\nimport mapValues from 'lodash/mapValues';\nimport {DEFAULT_META} from '../constants';\n\n/**\n * 生成 meta 对象\n *\n * @param  {Object|Array} target         目标对象\n * @param  {string}       [prefix='']    生成的 meta 对象的 key 值前缀\n * @param  {number}       [startIndex=0] 若 target 是一个数组，那么还可以额外指定 key 值的起始下标；\n *                                       但只对第一层级起效\n * @return {Object}\n */\nexport function make(target, prefix = '', startIndex = 0) {\n\n    const map = {};\n\n    let isRootArray = Array.isArray(target);\n\n    walk(target, (dataPath, value, isArray, tokens) => {\n\n        if (isRootArray) {\n\n            // 只对第一层进行处理\n            if (startIndex) {\n\n                let firstToken = tokens[0];\n                let numbericFirstToken = parseInt(firstToken, 10);\n\n                if (!isNaN(numbericFirstToken)) {\n                    dataPath = compilePath([\n                        numbericFirstToken + startIndex,\n                        ...tokens.slice(1)\n                    ]);\n                }\n\n            }\n\n        }\n\n        if (prefix) {\n            dataPath = `${prefix}${isRootArray ? '' : '.'}${dataPath}`;\n        }\n\n        map[dataPath] = value;\n\n    });\n\n    return map;\n\n}\n\nexport function remove(map, prefix) {\n\n    return Object\n        .keys(map)\n        .reduce((nextMap, key) => {\n\n            if (!startsWith(key, prefix)) {\n                nextMap[key] = map[key];\n            }\n\n            return nextMap;\n\n        }, {});\n\n}\n\nexport function move(map, from, to) {\n\n    return Object\n        .keys(map)\n        .reduce((nextMap, key) => {\n\n            if (startsWith(key, from)) {\n                nextMap[key.replace(from, to)] = map[key];\n            }\n            else {\n                nextMap[key] = map[key];\n            }\n\n            return nextMap;\n\n        }, {});\n\n}\n\nexport function splice(\n    map, pointer,\n    arr, start, deleteCount, replacements\n) {\n\n    const replaceCount = replacements.length;\n\n    // 删除\n    for (let i = 0; i < deleteCount; i++) {\n        map = remove(map, `${pointer}[${start + i}]`);\n    }\n\n    // 移动\n    if (deleteCount < replaceCount) {\n        for (let i = arr.length - start - deleteCount - 1; i >= 0; i--) {\n            let from = start + deleteCount + i;\n            let to = start + replacements.length + i;\n            map = move(map, `${pointer}[${from}]`, `${pointer}[${to}]`);\n        }\n    }\n    else if (deleteCount > replaceCount) {\n        for (\n            let i = 0, len = arr.length - start - deleteCount;\n            i < len;\n            i++\n        ) {\n            let from = start + deleteCount + i;\n            let to = start + replacements.length + i;\n            map = move(map, `${pointer}[${from}]`, `${pointer}[${to}]`);\n        }\n    }\n\n\n    // 添加\n    map = {\n        ...map,\n        ...mapValues(\n            make(replacements, pointer, start),\n            () => DEFAULT_META\n        )\n    };\n\n    return map;\n\n}\n\nexport function swap(map, dataPath, from, to) {\n\n    return Object\n        .keys(map)\n        .reduce((nextMap, key) => {\n\n            let fromKey = `${dataPath}[${from}]`;\n            let toKey = `${dataPath}[${to}]`;\n\n            if (startsWith(key, fromKey)) {\n                nextMap[key] = map[key.replace(fromKey, toKey)];\n            }\n            else if (startsWith(key, toKey)) {\n                nextMap[key] = map[key.replace(toKey, fromKey)];\n            }\n            else {\n                nextMap[key] = map[key];\n            }\n\n            return nextMap;\n\n        }, {});\n\n}\n\nexport function setInWithPath(map, dataPath, callback) {\n\n    const path = toPath(dataPath);\n    const toModifyKeyMap = path\n        .reduce((nextMap, item, index, path) => {\n\n            const currentPath = path.slice(0, index + 1);\n            const currentDataPath = compilePath(currentPath);\n\n            nextMap[currentDataPath] = typeof callback === 'function'\n                ? callback(map[currentDataPath], currentDataPath)\n                : callback;\n\n            return nextMap;\n\n        }, {});\n\n    return Object\n        .keys(map)\n        .reduce((nextMap, key) => {\n            nextMap[key] = key in toModifyKeyMap ? toModifyKeyMap[key] : map[key];\n            return nextMap;\n        }, {});\n\n}\n"]}